// 闭包从周围的作用域中捕获变量是简单明了的。
// 但是这样也存在一些问题：当使用闭包作为函数参数时，要求闭包是泛型，闭包的定义方式决定了这是闭包的。

// F 必须是泛型
// fn apply<F>(f: F) where F: FnOnce() {
//   fn();
// }

// 当闭包被定义，编译器会隐式的创建一个匿名类型的结构体，用以存储闭包捕获的变量，
// 同时为这个未知类型的机构提实现函数功能，通过Fn、FnMut或FnOnce三种trait中的一种。

// 若使用闭包作为函数参数，由于这个结构体的类型未知，任何的用法都要求是泛型的。
// 然而，使用未限定类型的参数<T>过于不明确，并且是不语序的。
// 事实上，指明为该结构体实现的Fn、FnMut、或FnOnce中的哪一种trait，对于约束该结构体的类型而言就已经足够了。


// F 必须是一个没有输入参数和返回值的闭包实现 Fn
fn apply<F>(f: F) where F: Fn() {
  f();
}

fn main() {
  let x = 7;
  let print = || println!("{}", x);

  apply(print);
}

