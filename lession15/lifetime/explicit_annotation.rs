// 显式标注

// 借用检查器使用显式的生命周期标记来明确引用的有效时间应该持续多久。
// 在生命周期没有省略（隐式标注）的情况下，Rust需要显式标注来确定引用的生命周期应该是什么样的。
// 可以用撇号'显式的标出生命周期，语法如下
// foo<'a>  foo带有一个生命周期参数 'a

// 和闭包类似，使用生命周期需要泛型。另外这个生命周期的语法也表明了foo的生命周期不能超出'a的周期（因为超出后，'a在foo里无法使用，导出报错）。
// 若要给类型显式地标注生命周期，其语法会像是&'aT这样。
// foo<'a, 'b>

// 其实一直想不通'a 'b到底是什么东西，是Rust的语法吗？必须这么写？写'c行不行？ 'z呢？
// 经过查阅一些博客，感觉类似是这样的：'a其实是一种标注，'a的生命周期需要通过所标注的参数或返回值的生命周期进行推断，
// 如果一个显示标注'a指向了多个参数，则'a的生命周期会取多个参数生命周期重叠的部分，也就是交集。
// 如果一个显示标注'a没有指向任何参数，则'a的生命周期非常长，也就是'static
// 当前函数的生命周期也不能超过任何一个显式标注的生命周期

// print_refs 接受两个i32类型的借用，它们有不同的生命周期 'a 和 'b
// 这两个生命周期都必须至少要和print_refs函数的生命周期一样长。
fn print_refs<'a, 'b>(x: &'a i32, y: &'b i32) {
    println!("x is {} and y is {}", x, y);
}

fn failed_borrow<'a>() {
    let _x = 21;

    // _x的生命周期比'a短（'a == 'static）,因此短生命周期不能强制转为长生命周期
    let _y: &'a i32 = &_x;
}

fn main() {
    let (four, nine) = (4, 9);

    // 任何被借用的输入量都必须比借用者的生命周期长
    print_refs(&four, &nine);

    // failed_borrow未包含引用，因此不需要要求'a长于函数的生命周期，
    // 但'a的生命周期更长，因为该生命周期从未被约束，所以默认为'static
    failed_borrow();
}
