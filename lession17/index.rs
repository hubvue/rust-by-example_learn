// 使用macro_rules!来创建宏
// Rust提供了一个强大的宏系统，可进行元编程。宏看起来和函数很像，只不过名称末尾有一个感叹号!。
// 宏并不产生函数调用，而是展开成源码，并和程序的其余部分一起编译。
// Rust又有一点和C以及其他语言都不同，那就是Rust的宏会展开为抽象语法树AST，而不是像字符串预处理那样直接替换成代码，这样就不会产生无法预料的优先权错误。

// 这是一个简单的宏
macro_rules! say_hello {
    // () 表示此宏不接受任何参数
    () => {
        // 此宏将会展开成这个代码块里的内容
        println!("Hello!");
    };
}

fn main() {
    // 这个调用将会展开为println!("Hello!");
    say_hello!();
}

// 为什么宏是有用的。
// 1.不写重复代码（DRY）。很多时候你需要在一些地方针对不同的类型实现类似的功能，这时常常可以使用宏来避免重复代码。
// 2.领域专用语言。宏允许你为特定的目的常遭特定的语法。
// 3.可变接口。有时你需要能够接受不定参数数目参数的忌口，比如println!,根据格式化字符串的不同，它需要接受任意多的参数。
